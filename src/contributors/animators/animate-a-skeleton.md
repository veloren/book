# Animating a Skeleton

Animation Tutorial
	
	Intro/Setup

Hi! This is slipped, I'm gonna use this tutorial to run through the basics of animation in Veloren and everything that you'd need to know to get started. I started the project with no real animation knowledge, so I've mostly slowly learned everything contained in here over the last year or so. Between this tutorial and some practice at learning the techniques, I think anyone will be able to pick up our animation system pretty quickly and be able to contribute to the project in this part of the codebase, which continues to expand.

So with that, setup! We use a feature cleverly built by Imbris that uses the `libloading` crate to hotload animations, meaning we can change animation scripts, save, and see those change in-game after a 2-10 second compile depending on  your system. No restarting the game or going into menus to see your changes. In order to acess the feature, first you'll need to go to `veloren/voxygen/src/anim/cargo.toml` amd uncomment this line `# crate-type = ["lib", "cdylib"]`. Next,  advance from root to the `voxygen` directory and use `cargo run --features "hot-anim` to run the game with the feature. Initial compile might be long but is worth it. 

	Skeletal Structure and Placement

So, the first thing we want to understand about animation is the workings of the skeleton. Each humanoid/animal in the game gets classified into a specific skeleton. The skeletons have, basically, two important aspects to consider when picking what kind of skeleton a new species might belong to: Bone structure and movement. For instance, `quadruped_low` is the skeleton that we use for larger reptile-likes, such as alligators and giant salamanders. This skeleton has qualities of both bone structure and movement. For bone structure, it features a two-part tail, which is good for better definition on larger tails, along with a simple foot dynamic that works off four foot bones, as opposed to some taller animals which might use both legs and feet to generate more detailed movement (8 bones). For the second part, movement, the key trait of `quadruped_low` is a lateral style movement, they don't bound up and down, rather, they shift laterally while they run. Think of `quadruped_low` as moving like a shark, rather than other quadrupeds that move like whales. But the details aren't important yet, that just gives a basic overview of how that one sksleton is unique when compared to the others. 

An important piece of skeletal structure to understand is the parenting scheme. In short, we can control the movement on every bone, but if that bone has children, then all of the children will automatically follow the same movement (from the parent's pivot point). We use this to our advantage often, and what you'll normally see is that a central, chest bone will be the parent (or grandparent!) of every bone. Typical scheme involves the chest being the parent of the leg bones, and the leg bones being the parent of the foot bones, that way legs and feet will move up with the chest, and feet will move with any movement that gets applied to the legs, and finally feet can move on their own. The chest bone will also typically be parent to a head bone, which might be parent to a jaw bone, and so on. It's important to know the relationships of the bones that you're trying to work with or things will get frustrating fast. For example, if you're trying to place the bones for a species, and you want to move a leg forward by two voxels but not the feet, you'll need to remember to move the legs forward two voxels and move the feet backward two voxels: The feet were moved with the leg change you made, as their parent, so therefore you need to do the reverse operation on the feet to bring them back to their original, proper position. 

[show the position stuff]

This gives you the gist of how we place the bones onto the skeleton, with all the different species of that body having their placement slightly different. These lists are called skeletal attributes, a big list of differences within the skeleton for individual species, broken down into different parameters. This though, is just a list, it doesn't actually do anything with these values yet so we'll get into that soon.

	Animation Basics

The animation files are, at their core, pretty simple. What you'll find if you start out is that animation is a very iterative process. The first goal is just to get your basic movement in place, maybe a sword rotation as the player's chest rotates, to swing. Once that's there, you can start adding additional detail to the movement, fleshing it out as you go to add things like foot movement, varying twist to the shorts and belt, tweaking the head to keep the eyes on the target. Often things can look pretty bleak until you find just the right addition that really makes it shine, and over time you get better at finding those key pieces. 

95% of our animation is done very simply with sine waves. There are a lot of small tricks that can put things over the top, but nothing that's necessary to know to get started. Movement is defined like this [equation], with this equation breaking down into just two key parts: frequency of the wave [], phase of the wave []. With those two tools we can do a whole lot. We don't use cosine in order to keep things consistent, so stick to +pi/2 to replicate cosine. What we lack here is amplitude, but we'll get into that. But what do these waves do, how do we plug them in, what's the point of multiple waves at different phases? More below.

[show position/angle/size]

This is what movement for a single bone looks like. Here we see position, a vec3 that controls movement in x (left/right) y (forward/back) and z (up/down). Remember skeleton attributes? well that's where these come in. We can see here, with a foot, we take the first value(0) and place it as the x position, then 2nd value as (1), etc. These are static values, so nothing is moving yet, we are just telling the game "hey, since you know this is a wolf, take the three values we gave you about wolf foot location and use them to place the foot". Next is rotations, which are use three different axes that can be multiplied together to do multi-axis rotation. X rotation happens along the x axis, so rotations in x on the head would tilt it forward and back, on Y would tilt it to the side and on Z would twist the head, along the vertical axis. Finally, dilations are last, which we don't use often except for varying the overall size of the model, or making things disappear when needed, like the glider. Size can be manipulated on any axis but we pretty much always use all 3 at once since the game is made of cubes. 

So how do these things intersect? Well, pretty easily. Here's a basic idle animation, you can see that we use the `breathe` wave and that it has a very low frequency here. We apply it to the chest, to raise and lower it in Z to replicate breathing, and would probably want to do the same to the hands, maybe a bit stronger, to keep the animation interesting. We can use multipliers to change the amplitude of the wave, keeping the behavior the same while changing how extremely it the wave movement is applied. One thing we would want to make sure of is that the feet don't move, since that wouldn't feel natural. in this case that's easy, the feet aren't parented to the chest for the humanoid so we don't need to worry about anything there.

Next, a quick snipped of the foot movement in a running animation for `quadruped_medium` which handles wolves and other things. You can see here that we play with a lot of factors, different waves working in different phases with each other to generate circle-like movement (Remember geometry!) [show formula for circle] along with further movement as rotation, since we want the foot to bend in tune with the movement. You'll also notice a .min(0.0) operation here, which is used to make sure that the foot never goes below a minimum point in Z, in other words, to replicate scraping the ground. The actual details of the exact phase that these need to be at to play well with each other isn't well suited for me to explain here, your best bet really is to play with these things, and also use tools like graph.tk to better visualize exactly what you're creating. Also keep in mind, a lot of this work is already completed. The `quadruped_medium` run is very fleshed out at this point, and it's trivial to reuse the work in other animations rather than reinventing the wheel. 

So those are the basics. We of course do things like gliding, sitting, climbing, sneaking, swimmming, eating and a ton of other animation, but really it all boils down to the same concepts and if you understand the concepts at play here then anything can be made with enough time.

	Animation Cool Stuff

I'll do some quick explanations of a few cool concepts that can be thrown into a lot of animations to up their quality a good bit. You don't need to know too much about the inner workings of them as the setup is all there, but you can find them mixed into the animations and try using them yourself. 

Animation layering: One important concept to understand is that the game features character states and base states. The player is always in a base state, they are idling, running, in-fluid (swim animation) and in-air (jump animation). On top of that, the player is often in a character state, which is usually an action rather than a movement, such as attacking, sitting, gliding, shielding, sneaking, wielding, etc. The most important thing to know about this is that the body will fall back on the movement state if it doesn't have a specific animation to carry out in the action state. So, for example, we may not want to give the feet any movement in the wielding state. We simply leave out instructions and the game will fall back to idle or running states, find the proper foot animation there and execute it. This both cuts down on work and limits the fracturing of code (which could often diverge and get messy). 

x_tilt: controls the angle of mobs as they increase or decrease elevation, that way the body actually rotates as you climb a hill to keep all four feet touching the ground (though we also use it on bipeds to a degree).

tilt: different from x_tilt, this uses changes in orientation to detect when the body has just strongly rotated. We use that to smooth those transitions, and give a sort of "motorcycle effect" that allow mobs to shift in and out of turns in a believable and stylish way.

head_look: Generates pseudo-random outputs that we use as multiplies for the rotation of the head. Really good for giving some life to an idle animation.

Pace system: Generates foot phasings intellgently based on the speed of the body, allowing you to go from a walking stride (LL,RR,LL,RR), to a running stride (LR,LR,LR,LR) and everything in-between smoothly. 

movement-based attributes: I talked earlier about how attributes are plugged into the animation files to define positions of limbs based on species, but they can also do much more. For example, we use a variable called `spring` in `quadruped_small` to define how much vertical movement there is in each step of an animal's movement. With that we can squeeze everything from a rabbit to a porcupine into the same skeleton, using the same animation, and have them look very different just based on attributes. It can also be used to generate behavior that is totally unique to a species, such as the pangolin run that brings it up on its hind legs. 


	Keyframes

Keyframes are a tricky concept and also very new to the codebase. No need to be great at these right off the bat. Basically, something I haven't mentioned until now is that there are two distinct kinds of Veloren animations: Cyclic and non-cyclic. The wave movement we've talked about so far is all cyclic, the waves will continue to propogate until another animation takes hold. Typically the non-cyclic animations are normalized, meaning that the anim_time variable will only reach 1, maximum. This is very good for us because it means that if the duration of an attack is slowed on the deeper, weapon characteristic level, the animation will simply slow to match it, while the range of motion remains the same. Without normalization, simple changes to duration of attacks would lead to the animation slipping out of its intended bounds and making ugly, undesired effects (and a lot more work).

So keyframes work well because we can break down an attack into 3 stages: buildup, swing, recovery. Typically the buildup and recovery and slow, while the swing is very quick. The normalization is, again, key here, since we don't really need to do extra work here. When the attack skill is created, it will have a short swing and longer buildup/duration, meaning that even with all else equal the swing movement will be fast. Generally,  the buildup starts at the wield position, we slowly move it to the start of the swing position, and then the swing takes over and finally the recovery begins at the end of the swing position and returns the weapon to the wield position. These movements are pretty easy to create since we can usually avoid sine waves and things of that nature, instead just using anim_time to create linear movement from point to point, with the variance in keyframe lengths doing the real work to make the movement look snappy. 

	Manifests

The manifests are the last big piece of how we animate. These files control the actual files that are grabbed for each species and tells the game about the position that they generate in at, relative to themselves. This concept can be tricky so I'm gonna use pictures and hpoefully I don't mess it up. 

First, each body has two manifests: lateral and central. Lateral contains anything that's paired with one on each side, central is everything else. They aren't separated for any real reason except that it makes them easier to work with when we aren't dealing with one massive file holding a hundred lines per species. The species are broken into male and female, which currently are almost always identical, since we don't do much male/female dimorphism yet, though we do want to eventually. The coordinates you get here are for initial position relative to the oriin in x,y,z.

The way this works is that each asset has a full size in voxels, and we want to use some fraction of that to define our pivot point, i.e., the position that the asset will rotate around. By default at 0,0,0 the model will rotate around a corner of itself, and also have a poorly offset position, so we don't want that. We generally want to center things. 

For example, here's the chest of an alligator. We want to center it, there's no need for any kind of fancy pivoting points here for the animations, we just want to create a plain center of mass at the midpoint of the model. Because the dimensions are 12,15,7 we center at half of those values, negated to correct the axes, so our pivot declared here is [-6,-7.5,-3.5]. Simple!

Next, only slightly more complex, the jaw of the same alligator, dimensions 8, 15, 3. We can still center this in x and z, but in this case for y we want to drag our pivot point all the way back to 0.0, in order to hinge at the back of the jaw when we rotate it in the animations. Important, or else he would look like a total mess when eating. So final setup is [-4, 0, -1.5]

Last example, a foot. We'll look at alligator left foot, dimensions 7,7,4. Foot rotation is particularly tricky, they get rotated in a lot of sophisticated ways and it's super obvious when I butcher this. Here, the final setup is [-7, 0,-4]. Basically, we want to drag the pivot all the way to the right in x since, since we clearly want this foot to attack to the chest and rotate out from it. y is also 0 here since the attachment point is sitting at the back of the model, so that's where we want to anchor to the chest. Finally, Z is -4 to place the pivot at the top. So the end result is placing the pivot in the corner. There are more examples of small ways that pivot points can vary in their setup, sometimes using 3/4 fractions if that's what fits the model, but that covers all the basics. These files hotload so feel free to play around and get instant feedback about how changing the pivot adjusts the animation.
